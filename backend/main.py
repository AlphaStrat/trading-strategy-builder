"""
FastAPI backend for Trading Strategy Builder
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import uuid
from validation import validate_strategy

app = FastAPI(title="Trading Strategy Builder API")

# CORS for React frontend (Vite defaults to 5173, CRA to 3000)
origins = [
    "http://localhost:3000",
    "http://localhost:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Data models
class IndicatorNode(BaseModel):
    id: str
    type: str  # "indicator", "condition", "action"
    name: str  # "RSI", "MACD", "SMA"
    parameters: Dict[str, Any] = {}
    position: Dict[str, float]  # x, y coordinates

class Connection(BaseModel):
    source: str
    target: str
    sourceHandle: Optional[str] = None
    targetHandle: Optional[str] = None

class Strategy(BaseModel):
    id: Optional[str] = None
    name: str
    nodes: List[IndicatorNode]
    connections: List[Connection]
    target_platform: str = "pinescript"  # pinescript, csharp, mql

# In-memory storage (replace with database later)
strategies_db = []

@app.get("/")
def read_root():
    return {"message": "Trading Strategy Builder API"}

@app.get("/api/indicators")
def get_available_indicators():
    """Get list of available indicators"""
    indicators = [
        {"id": "rsi", "name": "RSI", "category": "momentum", "default_params": {"period": 14}},
        {"id": "macd", "name": "MACD", "category": "trend", "default_params": {"fast": 12, "slow": 26, "signal": 9}},
        {"id": "sma", "name": "SMA", "category": "trend", "default_params": {"period": 20}},
        {"id": "ema", "name": "EMA", "category": "trend", "default_params": {"period": 20}},
        {"id": "bollinger", "name": "Bollinger Bands", "category": "volatility", "default_params": {"period": 20, "std_dev": 2}},
        {"id": "stochastic", "name": "Stochastic", "category": "momentum", "default_params": {"k": 14, "d": 3}},
        {"id": "atr", "name": "ATR", "category": "volatility", "default_params": {"period": 14}},
        {"id": "adx", "name": "ADX", "category": "trend", "default_params": {"period": 14}},
    ]
    return indicators

@app.post("/api/strategies")
def create_strategy(strategy: Strategy):
    """Save a new strategy"""
    if not strategy.id:
        strategy.id = str(uuid.uuid4())
    strategies_db.append(strategy.dict())
    return {"id": strategy.id, "message": "Strategy saved"}

@app.get("/api/strategies")
def get_strategies():
    """Get all saved strategies"""
    return strategies_db

@app.post("/api/compile/temp")
def compile_strategy_temp(strategy: Strategy, target: str = "pinescript"):
    """Compile strategy directly from payload without saving"""
    # Validate strategy
    try:
        validate_strategy(strategy.dict())
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Validation error: {str(e)}")

    # Compile based on target
    if target == "pinescript":
        code = compile_to_pinescript(strategy.dict())
    elif target == "csharp":
        code = compile_to_csharp(strategy.dict())
    elif target == "mql":
        code = compile_to_mql(strategy.dict())
    else:
        raise HTTPException(status_code=400, detail="Unsupported target language")
    
    return {"code": code, "language": target}

@app.post("/api/compile/{strategy_id}")
def compile_strategy(strategy_id: str, target: str = "pinescript"):
    """Compile saved strategy to target language"""
    # Find strategy
    strategy = next((s for s in strategies_db if s["id"] == strategy_id), None)
    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")
    
    return compile_strategy_temp(Strategy(**strategy), target)

def compile_to_pinescript(strategy: dict) -> str:
    """Compile to TradingView Pine Script with modular node logic"""
    code = []
    code.append(f"// Generated by Trading Strategy Builder")
    code.append(f"// Strategy: {strategy.get('name', 'Untitled')}")
    code.append("")
    code.append("//@version=5")
    code.append(f"strategy('{strategy.get('name', 'Untitled')}', overlay=true)")
    # 0. Pre-scan for SL/TP usage
    has_sl = False
    has_tp = False
    nodes = strategy.get("nodes", []) # Ensure nodes is defined for the pre-scan
    for node in nodes:
        if node.get("type", "").lower() in ["action", "actionnode"]:
            params = node.get("parameters", {})
            if params.get("actionType") == "buy":
                try:
                    sl_val = params.get("stopLoss")
                    tp_val = params.get("takeProfit")
                    # Treat None, empty string, or 0 as disabled
                    sl = float(sl_val) if sl_val not in [None, "", "0", 0] else 0
                    tp = float(tp_val) if tp_val not in [None, "", "0", 0] else 0
                    if sl > 0: has_sl = True
                    if tp > 0: has_tp = True
                except: pass

    # --- Strategy State Variables ---
    code.append("// --- Strategy State Variables ---")
    code.append("var bool positionOpen = false")
    code.append("var float entryPrice = na")
    if has_sl: code.append("var float stopLossPrice = na")
    if has_tp: code.append("var float takeProfitPrice = na")
    code.append("")

    nodes = strategy.get("nodes", [])
    connections = strategy.get("connections", [])
    
    # 1. Pre-process nodes and build dependency graph
    node_map = {node["id"]: node for node in nodes}
    node_vars = {}
    adj = {node["id"]: [] for node in nodes}
    in_degree = {node["id"]: 0 for node in nodes}

    for conn in connections:
        source_id = conn["source"]
        target_id = conn["target"]
        if source_id in adj and target_id in adj:
            adj[source_id].append(target_id)
            in_degree[target_id] += 1

    # 2. Topological Sort (Kahn's Algorithm)
    queue = [n_id for n_id, degree in in_degree.items() if degree == 0]
    sorted_nodes = []
    while queue:
        u = queue.pop(0)
        sorted_nodes.append(node_map[u])
        for v in adj[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)

    # 3. Map handles for each node
    # input_map: target_node_id -> { handle_id: source_node_id }
    input_map = {}
    for conn in connections:
        target = conn["target"]
        handle = conn.get("targetHandle") or 'default'
        source = conn["source"]
        if target not in input_map:
            input_map[target] = {}
        input_map[target][handle] = source

    def get_source_var(target_id, handle_id='default'):
        source_id = input_map.get(target_id, {}).get(handle_id)
        if not source_id:
            # Fallback for old 'a'/'default' mixup
            if handle_id == 'a':
                source_id = input_map.get(target_id, {}).get('default')
            elif handle_id == 'default':
                source_id = input_map.get(target_id, {}).get('a')
        return node_vars.get(source_id) if source_id else None

    # 4. Generate code in topological order
    code.append("// --- Indicator & Logic Calculations ---")
    code.append("can_buy = not positionOpen")
    code.append("can_sell = positionOpen")
    for node in sorted_nodes:
        node_id = node["id"]
        # Normalize type
        raw_type = node.get("type", "").lower()
        if raw_type.endswith("node"):
            nt = raw_type[:-4]
        else:
            nt = raw_type
        
        # Default to indicator if type is ambiguous but it has a name like RSI
        # Ignore input nodes (Strategy Start)
        if nt == "input" or node.get("name") == "Strategy Start":
            code.append(f"// {node.get('name', 'Input')} Node skipped")
            node_vars[node_id] = "close" # Fallback if connected
            continue

        params = node.get("parameters", {})
        
        node_var_base = node.get("name", "node").lower().replace(" ", "_").replace("<", "lt").replace(">", "gt")
        var_name = f"{node_var_base}_{str(node_id).split('-')[-1]}"
        node_vars[node_id] = var_name

        if nt == "indicator":
            name = node.get("name", "RSI")
            # Get source (default is 'close' if not connected)
            source_var = get_source_var(node_id, 'default') or get_source_var(node_id, 'a') or "close"
            
            if name == "RSI":
                period = params.get("period", 14)
                code.append(f"{var_name} = ta.rsi({source_var}, {period})")
                code.append(f"plot({var_name}, title='RSI {period}', color=color.purple, display=display.pane)")
                code.append(f"plot(70, title='RSI Upper', color=color.new(color.red, 50), display=display.pane)")
                code.append(f"plot(30, title='RSI Lower', color=color.new(color.green, 50), display=display.pane)")
            elif name == "SMA":
                period = params.get("period", 20)
                code.append(f"{var_name} = ta.sma({source_var}, {period})")
                code.append(f"plot({var_name}, title='SMA {period}', color=color.blue, linewidth=1)")
            elif name == "EMA":
                period = params.get("period", 20)
                code.append(f"{var_name} = ta.ema({source_var}, {period})")
                code.append(f"plot({var_name}, title='EMA {period}', color=color.orange, linewidth=1)")
            elif name == "MACD":
                fast = params.get("fast", 12)
                slow = params.get("slow", 26)
                signal = params.get("signal", 9)
                code.append(f"[{var_name}_line, {var_name}_sig, {var_name}_hist] = ta.macd({source_var}, {fast}, {slow}, {signal})")
                code.append(f"plot({var_name}_line, title='MACD Line', color=color.blue, display=display.pane)")
                code.append(f"plot({var_name}_sig, title='Signal Line', color=color.orange, display=display.pane)")
                code.append(f"plot({var_name}_hist, title='MACD Histogram', color=color.new(color.gray, 50), style=plot.style_columns, display=display.pane)")
                code.append(f"{var_name} = {var_name}_line")
            elif name == "Bollinger Bands":
                period = params.get("period", 20)
                std_dev = params.get("std_dev", 2)
                code.append(f"[{var_name}_upper, {var_name}_basis, {var_name}_lower] = ta.bb({source_var}, {period}, {std_dev})")
                code.append(f"plot({var_name}_upper, title='BB Upper', color=color.gray)")
                code.append(f"plot({var_name}_lower, title='BB Lower', color=color.gray)")
                code.append(f"plot({var_name}_basis, title='BB Basis', color=color.gray)")
                code.append(f"{var_name} = {var_name}_basis")
            else:
                code.append(f"{var_name} = close // Unknown indicator {name}")

        elif nt == "logic":
            operator = params.get("operator", "<")
            threshold = params.get("value", 0)
            
            var_a = get_source_var(node_id, 'a')
            var_b = get_source_var(node_id, 'b')
            
            # Use connected variable or static threshold
            operand_a = var_a if var_a else "close"
            operand_b = var_b if var_b else threshold
            
            if operator == "crossunder":
                code.append(f"{var_name} = ta.crossunder({operand_a}, {operand_b})")
            elif operator == "crossover":
                code.append(f"{var_name} = ta.crossover({operand_a}, {operand_b})")
            else:
                code.append(f"{var_name} = {operand_a} {operator} {operand_b}")

        elif nt == "action":
            action_type = params.get("actionType", "buy").lower()
            condition = get_source_var(node_id, 'default') # Action nodes usually have one input
            if not condition:
                condition = get_source_var(node_id, 'a') # Fallback
            
            if not condition:
                code.append(f"// action_{node_id} skipped: no condition connected")
                continue

            if action_type == "buy":
                # Check both top-level and nested for stopLoss/takeProfit
                sl_percent = params.get("stopLoss")
                if sl_percent is None:
                    sl_percent = params.get("parameters", {}).get("stopLoss", "")
                
                tp_percent = params.get("takeProfit")
                if tp_percent is None:
                    tp_percent = params.get("parameters", {}).get("takeProfit", "")
                
                # Treat empty strings or 0 as disabled
                is_sl_enabled = sl_percent not in [None, "", "0", 0]
                is_tp_enabled = tp_percent not in [None, "", "0", 0]

                try:
                    sl_val = float(sl_percent) if is_sl_enabled else 0
                    tp_val = float(tp_percent) if is_tp_enabled else 0
                except:
                    sl_val = 0
                    tp_val = 0
                
                trigger_var = f"buy_trigger_{str(node_id).split('-')[-1]}"
                code.append(f"{trigger_var} = {condition} and can_buy")
                code.append(f"if {trigger_var}")
                code.append(f"    strategy.entry('Long', strategy.long)")
                code.append(f"    positionOpen := true")
                code.append(f"    entryPrice := close")
                if has_sl: code.append(f"    stopLossPrice := {f'entryPrice * (1 - {sl_val} / 100)' if sl_val > 0 else 'na'}")
                if has_tp: code.append(f"    takeProfitPrice := {f'entryPrice * (1 + {tp_val} / 100)' if tp_val > 0 else 'na'}")
                code.append(f"plotshape({trigger_var}, title='Buy Signal', style=shape.labelup, location=location.belowbar, color=color.new(color.green, 0), size=size.small, text='BUY', textcolor=color.white)")
            elif action_type == "sell":
                trigger_var = f"sell_trigger_{str(node_id).split('-')[-1]}"
                code.append(f"{trigger_var} = {condition} and can_sell")
                code.append(f"if {trigger_var}")
                code.append(f"    strategy.close('Long', comment='Sell Signal')")
                code.append(f"    positionOpen := false")
                code.append(f"    entryPrice := na")
                if has_sl: code.append(f"    stopLossPrice := na")
                if has_tp: code.append(f"    takeProfitPrice := na")
                code.append(f"plotshape({trigger_var}, title='Sell Signal', style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 0), size=size.small, text='SELL', textcolor=color.white)")

    code.append("")
    if has_sl or has_tp:
        code.append("")
        code.append("// --- Exit Logic (Stop Loss & Take Profit) ---")
        code.append(f"stopHit = positionOpen and {'not na(stopLossPrice) and close < stopLossPrice' if has_sl else 'false'}")
        code.append(f"targetHit = positionOpen and {'not na(takeProfitPrice) and close > takeProfitPrice' if has_tp else 'false'}")
        code.append("exit_trigger = stopHit or targetHit")
        code.append("if exit_trigger")
        code.append("    strategy.close('Long', comment = stopHit ? 'Stop Loss Hit' : 'Take Profit Hit')")
        code.append("    positionOpen := false")
        code.append("    entryPrice := na")
        if has_sl: code.append("    stopLossPrice := na")
        if has_tp: code.append("    takeProfitPrice := na")
        code.append("")
        if has_sl:
            code.append("// Stop-loss exit label")
            code.append("plotshape(stopHit, title='Stop Exit', style=shape.labeldown, location=location.abovebar, color=color.red, size=size.small, text='STOP', textcolor=color.white)")
        if has_tp:
            code.append("// Take-profit exit label")
            code.append("plotshape(targetHit, title='TP Exit', style=shape.labeldown, location=location.abovebar, color=color.green, size=size.small, text='TP', textcolor=color.white)")
        code.append("")

    code.append("// --- Plotting Entry/Stop/TP ---")
    code.append("plot(entryPrice, title='Entry Price', color=color.new(color.green, 0), style=plot.style_linebr)")
    if has_sl: code.append("plot(stopLossPrice, title='Stop Loss Price', color=color.new(color.red, 0), style=plot.style_linebr)")
    if has_tp: code.append("plot(takeProfitPrice, title='Take Profit Price', color=color.new(color.lime, 0), style=plot.style_linebr)")

    return "\n".join(code)


def compile_to_csharp(strategy: dict) -> str:
    """Compile to NinjaTrader C#"""
    return f"""// NinjaTrader C# Strategy
// Generated for: {strategy.get('name', 'Untitled')}
// TODO: Implement full C# compilation
"""

def compile_to_mql(strategy: dict) -> str:
    """Compile to MetaTrader MQL"""
    return f"""// MetaTrader MQL Strategy  
// Generated for: {strategy.get('name', 'Untitled')}
// TODO: Implement full MQL compilation
"""

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8010)
